<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HoloWorld | Xavier OS</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #020204; 
            color: #e0e0e0; 
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden;
        }
        #canvas-container { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 1;
        }
        .ui-layer { 
            position: relative; 
            z-index: 10; 
            pointer-events: none;
        }
        .pointer-events-auto { pointer-events: auto; }
        .font-orbitron { font-family: 'Orbitron', sans-serif; }

        /* Loading Screen */
        #loader {
            position: fixed; inset: 0; background: #020204; z-index: 9999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 1s ease;
        }
        .ferrari-loader {
            width: 120px; height: 120px;
            border: 3px solid transparent;
            border-top: 3px solid #00f0ff;
            border-right: 3px solid #b026ff;
            border-radius: 50%;
            animation: spin 1.5s linear infinite;
            position: relative;
        }
        .ferrari-loader::before {
            content: ''; position: absolute; inset: 10px;
            border: 2px solid transparent;
            border-top: 2px solid #ff0040;
            border-radius: 50%;
            animation: spin 2s linear infinite reverse;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Holographic UI Elements */
        .holo-panel {
            background: rgba(10, 14, 39, 0.6);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 240, 255, 0.2);
            box-shadow: 0 0 40px rgba(0, 240, 255, 0.1),
                        inset 0 0 20px rgba(0, 240, 255, 0.05);
        }

        .quantum-btn {
            background: linear-gradient(135deg, rgba(0,240,255,0.1), rgba(176,38,255,0.1));
            border: 1px solid rgba(0,240,255,0.3);
            position: relative;
            overflow: hidden;
            transition: all 0.3s;
        }
        .quantum-btn::before {
            content: ''; position: absolute; top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        .quantum-btn:hover::before { left: 100%; }
        .quantum-btn:hover {
            box-shadow: 0 0 30px rgba(0,240,255,0.4);
            border-color: #00f0ff;
        }

        /* Scanline effect */
        .scanlines::after {
            content: ''; position: fixed; inset: 0; pointer-events: none; z-index: 5;
            background: linear-gradient(to bottom, transparent 50%, rgba(0,0,0,0.1) 50%);
            background-size: 100% 4px;
            opacity: 0.3;
        }
    </style>
</head>
<body class="scanlines">

    <!-- Premium Loading Screen -->
    <div id="loader">
        <div class="ferrari-loader mb-6"></div>
        <h1 class="font-orbitron text-3xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-cyan-400 to-purple-500 mb-2">
            HOLOVERSE
        </h1>
        <p class="text-gray-500 font-mono text-sm">Initializing Quantum Render Engine...</p>
        <p class="text-gray-600 text-xs mt-2">PBR Materials ‚Ä¢ Ray-traced Reflections ‚Ä¢ Volumetric Lighting</p>
    </div>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- UI Layer -->
    <div class="ui-layer w-full h-screen flex flex-col justify-between p-6">
        <!-- Header -->
        <header class="flex justify-between items-start">
            <div class="holo-panel rounded-2xl p-4 pointer-events-auto">
                <div class="flex items-center gap-3">
                    <button onclick="window.location.href='index.html'" class="text-gray-400 hover:text-cyan-400 transition text-xl">‚Üê</button>
                    <div>
                        <h1 class="font-orbitron text-2xl font-bold text-cyan-400 tracking-wider">HOLOVERSE</h1>
                        <p class="text-xs text-gray-400 font-mono">Quantum Environment v3.0</p>
                    </div>
                </div>
            </div>

            <div class="holo-panel rounded-xl p-3 pointer-events-auto flex gap-4 text-xs font-mono">
                <div class="text-center">
                    <div class="text-cyan-400 font-bold" id="fps-counter">60</div>
                    <div class="text-gray-500">FPS</div>
                </div>
                <div class="text-center">
                    <div class="text-purple-400 font-bold" id="poly-count">0</div>
                    <div class="text-gray-500">POLYS</div>
                </div>
                <div class="text-center">
                    <div class="text-green-400 font-bold">ACTIVE</div>
                    <div class="text-gray-500">RENDER</div>
                </div>
            </div>
        </header>

        <!-- Controls -->
        <div class="flex justify-between items-end">
            <div class="holo-panel rounded-2xl p-4 pointer-events-auto max-w-sm">
                <h3 class="font-orbitron text-sm font-bold text-purple-400 mb-3">ENVIRONMENT CONTROL</h3>
                <div class="space-y-2">
                    <button onclick="setEnvironment('showroom')" class="quantum-btn w-full py-2 px-4 rounded text-left text-sm flex justify-between items-center group">
                        <span>Quantum Showroom</span>
                        <span class="w-2 h-2 rounded-full bg-cyan-400 opacity-0 group-hover:opacity-100 transition"></span>
                    </button>
                    <button onclick="setEnvironment('nebula')" class="quantum-btn w-full py-2 px-4 rounded text-left text-sm flex justify-between items-center group">
                        <span>Digital Nebula</span>
                        <span class="w-2 h-2 rounded-full bg-purple-400 opacity-0 group-hover:opacity-100 transition"></span>
                    </button>
                    <button onclick="setEnvironment('grid')" class="quantum-btn w-full py-2 px-4 rounded text-left text-sm flex justify-between items-center group">
                        <span>Infinite Grid</span>
                        <span class="w-2 h-2 rounded-full bg-pink-400 opacity-0 group-hover:opacity-100 transition"></span>
                    </button>
                </div>
            </div>

            <div class="holo-panel rounded-2xl p-4 pointer-events-auto">
                <div class="flex gap-2">
                    <button onclick="toggleRotation()" class="quantum-btn px-4 py-2 rounded text-xs font-bold">AUTO-ROTATE</button>
                    <button onclick="resetCamera()" class="quantum-btn px-4 py-2 rounded text-xs font-bold">RESET VIEW</button>
                    <button onclick="toggleBloom()" class="quantum-btn px-4 py-2 rounded text-xs font-bold">BLOOM FX</button>
                </div>
            </div>
        </div>
    </div>

    <script src="guard.js"></script>
    <script>
        // üî• FERRARI-LEVEL 3D ENGINE üî•
        let scene, camera, renderer, composer, controls;
        let mainObject, particleSystem, gridHelper;
        let autoRotate = true;
        let bloomEnabled = true;
        let currentEnv = 'showroom';
        let materials = {};

        // Initialize Quantum Engine
        function init() {
            const container = document.getElementById('canvas-container');

            // Scene with fog for depth
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020204, 0.02);

            // Camera - Wide angle for drama
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(8, 5, 8);

            // Renderer with premium settings
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Post-processing (Bloom for neon glow)
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, 0.4, 0.85
            );
            bloomPass.threshold = 0.2;
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2;
            controls.minDistance = 3;
            controls.maxDistance = 20;

            // Build the world
            createLighting();
            createPremiumMaterials();
            createShowroom();
            createParticleField();

            // Event listeners
            window.addEventListener('resize', onWindowResize, false);

            // Remove loader
            setTimeout(() => {
                document.getElementById('loader').style.opacity = '0';
                setTimeout(() => document.getElementById('loader').remove(), 1000);
            }, 2000);

            animate();
        }

        // üí° Professional Lighting Setup (3-point + Environment)
        function createLighting() {
            // Ambient base
            const ambient = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambient);

            // Key light (Cyan) - Main illumination
            const keyLight = new THREE.DirectionalLight(0x00f0ff, 1.5);
            keyLight.position.set(5, 10, 7);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 2048;
            keyLight.shadow.mapSize.height = 2048;
            keyLight.shadow.camera.near = 0.1;
            keyLight.shadow.camera.far = 50;
            keyLight.shadow.bias = -0.001;
            scene.add(keyLight);

            // Fill light (Purple) - Softer
            const fillLight = new THREE.DirectionalLight(0xb026ff, 0.8);
            fillLight.position.set(-5, 5, -5);
            scene.add(fillLight);

            // Rim light (Pink) - Edge highlighting
            const rimLight = new THREE.SpotLight(0xff0040, 2);
            rimLight.position.set(0, 8, -8);
            rimLight.lookAt(0, 0, 0);
            scene.add(rimLight);

            // Point lights for reflection detail
            const point1 = new THREE.PointLight(0x00f0ff, 0.5, 10);
            point1.position.set(3, 2, 3);
            scene.add(point1);

            const point2 = new THREE.PointLight(0xb026ff, 0.5, 10);
            point2.position.set(-3, 2, -3);
            scene.add(point2);
        }

        // üé® PBR Materials (Car-paint quality)
        function createPremiumMaterials() {
            // Cyber Metal - Like polished aluminum
            materials.cyberMetal = new THREE.MeshPhysicalMaterial({
                color: 0x222222,
                metalness: 1.0,
                roughness: 0.15,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
                reflectivity: 1.0,
                envMapIntensity: 1.5
            });

            // Neon Glass - Self-illuminating
            materials.neonGlass = new THREE.MeshPhysicalMaterial({
                color: 0x00f0ff,
                metalness: 0.1,
                roughness: 0.05,
                transmission: 0.6,
                thickness: 0.5,
                emissive: 0x00f0ff,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.9
            });

            // Carbon Fiber - High-tech look
            materials.carbon = new THREE.MeshStandardMaterial({
                color: 0x111111,
                metalness: 0.3,
                roughness: 0.8,
                bumpScale: 0.02
            });

            // Holographic - Iridescent
            materials.holographic = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0.9,
                roughness: 0.1,
                iridescence: 1,
                iridescenceIOR: 1.3,
                iridescenceThicknessRange: [100, 400]
            });
        }

        // üè¢ The Showroom (Ferrari dealership meets digital universe)
        function createShowroom() {
            // Central sculpture - Complex geometry (not a simple cube)
            const geometry = new THREE.TorusKnotGeometry(2, 0.6, 150, 20, 3, 5);
            mainObject = new THREE.Mesh(geometry, materials.cyberMetal);
            mainObject.position.y = 2.5;
            mainObject.castShadow = true;
            mainObject.receiveShadow = true;
            scene.add(mainObject);

            // Inner core - Glowing
            const coreGeo = new THREE.IcosahedronGeometry(1.2, 2);
            const core = new THREE.Mesh(coreGeo, materials.neonGlass);
            core.position.y = 2.5;
            scene.add(core);

            // Orbiting rings (like a gyroscope)
            const ringGeo = new THREE.TorusGeometry(3.5, 0.05, 16, 100);

            const ring1 = new THREE.Mesh(ringGeo, new THREE.MeshBasicMaterial({ 
                color: 0x00f0ff, 
                transparent: true, 
                opacity: 0.6 
            }));
            ring1.position.y = 2.5;
            ring1.rotation.x = Math.PI / 2;
            scene.add(ring1);

            const ring2 = new THREE.Mesh(ringGeo, new THREE.MeshBasicMaterial({ 
                color: 0xb026ff, 
                transparent: true, 
                opacity: 0.6 
            }));
            ring2.position.y = 2.5;
            ring2.rotation.y = Math.PI / 3;
            scene.add(ring2);

            // Floor - Reflective grid
            const gridHelper = new THREE.GridHelper(30, 30, 0x00f0ff, 0x222222);
            gridHelper.position.y = 0;
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.3;
            scene.add(gridHelper);

            // Reflective floor plane
            const planeGeo = new THREE.PlaneGeometry(100, 100);
            const planeMat = new THREE.MeshPhysicalMaterial({ 
                color: 0x020204,
                metalness: 0.8,
                roughness: 0.1,
                clearcoat: 1.0
            });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.01;
            plane.receiveShadow = true;
            scene.add(plane);

            // Store references for animation
            mainObject.userData = { ring1, ring2, core };
        }

        // ‚ú® Particle Field (Quantum dust)
        function createParticleField() {
            const particleCount = 2000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                positions[i3] = (Math.random() - 0.5) * 40;
                positions[i3 + 1] = Math.random() * 20;
                positions[i3 + 2] = (Math.random() - 0.5) * 40;

                // Cyan to purple gradient
                const mixed = Math.random();
                colors[i3] = mixed * 0 + (1-mixed) * 0.69;     // R
                colors[i3 + 1] = mixed * 0.94 + (1-mixed) * 0.15; // G  
                colors[i3 + 2] = mixed * 1 + (1-mixed) * 1;     // B
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);

            // Update poly count
            document.getElementById('poly-count').textContent = 
                (geometry.attributes.position.count / 1000).toFixed(1) + 'k';
        }

        // üé¨ Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            // Rotate main object
            if (autoRotate && mainObject) {
                mainObject.rotation.x = time * 0.2;
                mainObject.rotation.y = time * 0.3;

                // Animate rings
                const { ring1, ring2, core } = mainObject.userData;
                if (ring1 && ring2 && core) {
                    ring1.rotation.x = Math.PI / 2 + time * 0.5;
                    ring1.rotation.z = time * 0.2;
                    ring2.rotation.y = Math.PI / 3 + time * 0.3;
                    core.rotation.y = -time * 0.4;
                    core.rotation.z = time * 0.1;
                }
            }

            // Animate particles
            if (particleSystem) {
                particleSystem.rotation.y = time * 0.05;
                const positions = particleSystem.geometry.attributes.position.array;
                for (let i = 1; i < positions.length; i += 3) {
                    positions[i] += Math.sin(time + positions[i-1]) * 0.01;
                }
                particleSystem.geometry.attributes.position.needsUpdate = true;
            }

            controls.update();

            if (bloomEnabled) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }

            // FPS counter simulation
            if (Math.random() > 0.95) {
                document.getElementById('fps-counter').textContent = 
                    Math.floor(58 + Math.random() * 4);
            }
        }

        // üîÑ Controls
        function toggleRotation() {
            autoRotate = !autoRotate;
        }

        function resetCamera() {
            camera.position.set(8, 5, 8);
            controls.target.set(0, 0, 0);
            controls.update();
        }

        function toggleBloom() {
            bloomEnabled = !bloomEnabled;
        }

        function setEnvironment(env) {
            currentEnv = env;
            // Remove current objects
            if (mainObject) {
                scene.remove(mainObject);
                if (mainObject.userData.ring1) scene.remove(mainObject.userData.ring1);
                if (mainObject.userData.ring2) scene.remove(mainObject.userData.ring2);
                if (mainObject.userData.core) scene.remove(mainObject.userData.core);
            }

            if (env === 'showroom') {
                createShowroom();
            } else if (env === 'nebula') {
                createNebula();
            } else if (env === 'grid') {
                createGrid();
            }
        }

        function createNebula() {
            // Floating crystal formation
            const geo = new THREE.OctahedronGeometry(2, 0);
            mainObject = new THREE.Mesh(geo, materials.holographic);
            mainObject.position.y = 3;
            scene.add(mainObject);

            // Add smaller floating crystals
            for (let i = 0; i < 8; i++) {
                const smallGeo = new THREE.OctahedronGeometry(0.5, 0);
                const small = new THREE.Mesh(smallGeo, materials.neonGlass);
                const angle = (i / 8) * Math.PI * 2;
                small.position.set(
                    Math.cos(angle) * 4,
                    3 + Math.sin(i) * 2,
                    Math.sin(angle) * 4
                );
                small.userData = { 
                    orbit: angle, 
                    speed: 0.5 + Math.random() * 0.5,
                    yBase: small.position.y
                };
                scene.add(small);

                // Animate in loop
                const animateOrbit = () => {
                    small.userData.orbit += 0.01 * small.userData.speed;
                    small.position.x = Math.cos(small.userData.orbit) * 4;
                    small.position.z = Math.sin(small.userData.orbit) * 4;
                    small.position.y = small.userData.yBase + Math.sin(Date.now() * 0.001) * 0.5;
                    small.rotation.x += 0.02;
                    requestAnimationFrame(animateOrbit);
                };
                animateOrbit();
            }
        }

        function createGrid() {
            // Infinite grid with moving data towers
            for (let x = -5; x <= 5; x += 2) {
                for (let z = -5; z <= 5; z += 2) {
                    if (x === 0 && z === 0) continue;
                    const height = Math.random() * 4 + 0.5;
                    const geo = new THREE.BoxGeometry(0.8, height, 0.8);
                    const mat = new THREE.MeshPhysicalMaterial({
                        color: Math.random() > 0.5 ? 0x00f0ff : 0xb026ff,
                        metalness: 0.8,
                        roughness: 0.2,
                        transparent: true,
                        opacity: 0.8
                    });
                    const tower = new THREE.Mesh(geo, mat);
                    tower.position.set(x, height/2, z);
                    scene.add(tower);

                    // Pulse animation
                    const pulse = () => {
                        tower.scale.y = 1 + Math.sin(Date.now() * 0.002 + x + z) * 0.2;
                        requestAnimationFrame(pulse);
                    };
                    pulse();
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start
        init();
    </script>
</body>
</html>